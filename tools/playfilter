#!/bin/sh
set -f
set -o pipefail

readonly AWK=${AWK:-/usr/bin/awk}
readonly CAT=${CAT:-/bin/cat}


readonly ERRORS='
OK
E_USAGE
E_READ_CONCAT
E_READ_COLUMNS
E_FILTER_UNKNOWN
E_FILTER_ORDER
E_FILTER_NOMATCH
E_FILTER_MOVINGAVG_RANGE
E_FILTER_HORIZ_UNIT
E_FILTER_STYLE_UNKNOWN
'

errno=-1
for error in ${ERRORS}; do
	readonly ${error}=$((errno += 1))
done

selectp() {
	local expr i
	expr="${1}"
	shift
	i=0
	while [ $((i += 1)) -le $# ]; do
		eval "case \"\${${i}%\\[*\\]}\" in
		${expr})
			echo ${i}
		;;
		esac"
	done
}

select() {
	join "${1}" $(shift; selectp "$@")
	if eval "[ -z \"\${$1}\" ]"; then
		echo "error: ${FILTER}: no column match for: ${2}" >&2
		exit ${E_FILTER_NOMATCH}
	fi
}

join() {
	setvar "${1}" "$(shift; echo "$*")"
}

filter_movingavg() {
	local head columns
	read -r head
	select columns "${1}" ${head}
	echo "${head}"
	if ! ${AWK} -f "${0}.movingavg.awk" \
	            -vCOLUMNS="${columns}" -vPRE="${2}" -vPOST="${3}"; then
		exit ${E_FILTER_MOVINGAVG_RANGE}
	fi
}

filter_subsample() {
	${AWK} -vWRAP="${1}" 'NR % int(WRAP) == 1'
}

filter_cut() {
	local head columns
	read -r head
	select columns "${1}" ${head}
	IFS=, join columns $(printf '$%d ' ${columns})
	(echo "${head}"; ${CAT}) | ${AWK} "{ print(${columns}) }"
}

filter_horiz() {
	local head columns
	read -r head
	select columns "${1}" ${head}
	if ! (echo "${head}"; ${CAT}) | \
	     ${AWK} -f "${0}.horiz.awk" \
	            -vALGO="${FILTER#h}" -vCOLUMNS="${columns}"; then
		exit ${E_FILTER_HORIZ_UNIT}
	fi
}

filter_patch() {
	local head columns
	read -r head
	select columns "${1}" ${head}
	columns="$(printf 'COLUMNS[%d];' ${columns})"
	echo "${head}"
	${AWK} "
	BEGIN { ${columns} }
	{
		for (c in COLUMNS) {
			if (PREV[c] >= \$c) {
				ADD[c] += PREV[c]
			}
			PREV[c] = \$c
			\$c += ADD[c]
		}
		print
	}
	"
}

filter_clone() {
	local head columns
	read -r head
	select columns "${1}" ${head}
	columns="$(printf 'COLUMNS[%d];' ${columns})"
	(echo "${head}"; ${CAT}) | ${AWK} -vCLONES="${2}" "
	BEGIN {
		${columns}
		CLONES += 0
	}
	NR == 1 {
		COLS = NF
		for (c = 1; c <= COLS; ++c) {
			if (!(c in COLUMNS)) {
				continue
			}
			for (clone = 0; clone < CLONES; ++clone) {
				name = \$c
				sub(/(\\[.*\\])?\$/, \".\" clone \"&\", name)
				\$++NF = name
			}
		}
	}
	NR > 1 {
		for (c = 1; c <= COLS; ++c) {
			if (!(c in COLUMNS)) {
				continue
			}
			for (clone = 0; clone < CLONES; ++clone) {
				\$++NF = \$c
			}
		}
	}
	1
	"
}

filter_precision() {
	local head columns
	read -r head
	select columns "${1}" ${head}
	columns="$(printf 'COLUMNS[%d];' ${columns})"
	echo "${head}"
	${AWK} -vPRECISION="${2}" "
	BEGIN {
		PRECISION += 0
		FMT = \"%.\" PRECISION \"f\"
		${columns}
	}
	{
		for (c in COLUMNS) {
			\$c = sprintf(FMT, \$c)
		}
	}
	1
	"
}

filter_style() {
	case "${1}" in
	[Cc][Ss][Vv])
		${AWK} -vOFS=, '
		NR == 1 {
			for (c = 1; c <= NF; ++c) {
				$c = "\"" $c "\""
			}
		}
		{
			$1 = $1
			print
		}
		'
	;;
	[Mm][Dd])
		${AWK} '
		BEGIN {
			OFS=""
			ORS="|\n"
		}
		NR == 1 {
			for (c = 1; c <= NF; ++c) {
				LEN[c] = length($c)
			}
		}
		{
			for (c = 1; c <= NF; ++c) {
				$c = sprintf("| %" LEN[c] "s ", $c)
			}
			print
		}
		NR == 1 {
			for (c = 1; c <= NF; ++c) {
				gsub(/[^|]/, "-", $c)
				sub(/.$/, ":", $c)
			}
			print
		}
		'
	;;
	*)
		echo "error: style: unsupported formatting: ${1}" >&2
		exit ${E_FILTER_STYLE_UNKNOWN}
	;;
	esac

}

runFilter() {
	local IFS
	IFS=,
	case "${1}" in
	cut=*|movingavg=*|subsample=*|patch=*|clone=*|precision=*)
		FILTER="${1%%=*}" IFS=$' \n\t' filter_${1%%=*} ${1#*=}
	;;
	hmax=*|hmin=*|hsum=*|havg=*)
		FILTER="${1%%=*}" IFS=$' \n\t' filter_horiz ${1#*=}
	;;
	style=*)
		if [ -n "${FINAL}" ]; then
			FILTER="${1%%=*}" IFS=$' \n\t' filter_${1%%=*} ${1#*=}
		else
			echo "error: ${1%%=*}: must be the final filter" >&2
			exit ${E_FILTER_ORDER}
		fi
	;;
	*)
		echo "error: not a valid filter: ${1}" >&2
		exit ${E_FILTER_UNKNOWN}
	;;
	esac
}

runFilterPipeline() {
	if [ -n "${2}" -a -z "${2##*=*}" ]; then
		FINAL= runFilter "${1}" | (shift; runFilterPipeline "$@")
		return
	fi
	FINAL=1 runFilter "${1}"
}

runFilters() {
	if [ $# -eq 0 ]; then
		local errno error
		echo "usage: ${0} [ filters... ] [--] [ files... ]"
		printf "%8s  %s\n" "Exit no." "Exit symbol"
		errno=-1
		for error in ${ERRORS}; do
			printf " %6d    %s\n" $((errno += 1)) "${error}"
		done
		exit ${E_USAGE}
	fi
	if [ -z "${1##*=*}" ]; then
		runFilterPipeline "$@"
		return
	fi
	${CAT}
}

readFiles() {
	[ $# -eq 0 ] && return
	while [ -z "${1##*=*}" ] && shift; do :; done
	[ "${1}" == "--" ] && shift
	${AWK} "
	NR == 1 { 
		for (c = 1; c <= NF; ++c) {
			HEADER[c] = \$c
		}
		HEADER_NF = NF
	}
	NF != HEADER_NF {
		print \"error: \" FILENAME \":\" FNR \": mismatching number of columns\" > \"/dev/stderr\"
		exit ${E_READ_COLUMNS}
	}
	FNR != NR && FNR == 1 {
		for (c in HEADER) {
			if (\$c != HEADER[c]) {
				print \"error: \" FILENAME \":\" FNR \": column name mismatch\" > \"/dev/stderr\"
				print \"hint:  \" \$c \" != \" HEADER[c] > \"/dev/stderr\"
				exit ${E_READ_CONCAT}
			}
		}
		next
	}
	1
	" "$@"
}

readFiles "$@" | runFilters "$@"
