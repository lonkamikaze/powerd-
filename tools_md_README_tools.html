<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>powerd++: TOOLS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">powerd++
   &#160;<span id="projectnumber">0.4.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">TOOLS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tools_md_README_playdiff"></a>
playdiff</h1>
<p>Computes metrics of the deviations between two <code>loadplay(1)</code> generated outputs.</p>
<div class="fragment"><div class="line">usage: tools/playdiff file1 file2 ...</div>
</div><!-- fragment --><p>The output of <code>loadplay(1)</code> is not reproducible. Due to differences in timing between each run there are slight variations in the load that a powerd samples. This makes it difficult to tell whether a second run with a different parameter set or a different powerd version exhibits different behaviour, which is important for regression testing.</p>
<p>The most intuitive way of dealing with this is plotting a graph. The <code>playdiff</code> tool instead provides metrics to make the same judgement.</p>
<h2>Metrics</h2>
<p>The <code>playdiff</code> tool integrates the deviations and absolute deviations between two <code>loadplay</code> outputs over time. These values are used to present four metrics per column of <code>loadplay</code> output:</p>
<ul>
<li>Integral over Deviations (ID)</li>
<li>Mean Deviation (MD)</li>
<li>Integral over Absolute Deviations (IAD)</li>
<li>Mean Absolute Deviation (MAD)</li>
</ul>
<h2>Interpreting the Data</h2>
<p>The integrals and means provide the same information, but the magnitude of the means is independent of the duration of the load replay, thus the means make it easier to interpret the data.</p>
<p>The following excerpt of a real dataset, shows the IAD looks high, the MAD is a much better presentation. An average CPU frequency deviation of 34 MHz is noteworthy, but not indicative of a fundamental difference.</p>
<p>A look at the MAD column of the <code>run.load</code> row shows that <code>loadplay</code> presented different load data to the powerd between runs. The <code>rec.load</code> row confirms that both runs are based on the same recording. However the ID column shows that the accumulated deviation over the entire run is less than 0.05 MHz. This is indicative of an aliasing effect that implies there was a small time offset between both runs, apart from that performance of the powerd was the same.</p>
<div class="fragment"><div class="line">--- a/load.play</div>
<div class="line">+++ b/load.play</div>
<div class="line">                                ID            MD           IAD           MAD</div>
<div class="line">time[s]                        0.0           0.0           0.0           0.0</div>
<div class="line">cpu.0.rec.freq[MHz]            0.0           0.0           0.0           0.0</div>
<div class="line">cpu.0.rec.load[MHz]            0.0           0.0           0.0           0.0</div>
<div class="line">cpu.0.run.freq[MHz]          -94.0          -3.1        1016.0          33.9</div>
<div class="line">cpu.0.run.load[MHz]            0.0           0.0         160.0           5.3</div>
</div><!-- fragment --><h1><a class="anchor" id="tools_md_README_playfilter"></a>
playfilter</h1>
<p>Post-process loadplay(1) output.</p>
<div class="fragment"><div class="line">usage: tools/playfilter [ filters... ] [--] [ files... ]</div>
</div><!-- fragment --><p>Takes an optional list of filters and an optional list of files. The first argument not matching the syntax for a filter is treated as a file. Alternatively the <code>--</code> argument can be provided to mark the end of the list of filters. This allows providing file names that look like filters.</p>
<p>The syntax for a filter is <code>FILTER=ARG[,...]</code>. Individual filters are described in the <a href="#tools_md_README_filters">Filters</a> subsection.</p>
<h2>Files</h2>
<p>If no file names are given, <code>stdin</code> is used as the input. Otherwise the given files are concatenated. Each line of input is expected to contain a fixed number of fields separated by white space. The first line of each file is referred to as the header and expected to contain the column names.</p>
<p>Subsequent headers are discarded if they match the first file's header. A mismatch is treated as an error.</p>
<h2>Filters</h2>
<p>The following filters are supported.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Filter </th><th class="markdownTableHeadNone">Arguments </th><th class="markdownTableHeadNone">Describe  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cut </td><td class="markdownTableBodyNone">glob </td><td class="markdownTableBodyNone">Remove unmatched columns  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">movingavg </td><td class="markdownTableBodyNone">glob pre [post] </td><td class="markdownTableBodyNone">Apply a moving average (mean)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">subsample </td><td class="markdownTableBodyNone">n </td><td class="markdownTableBodyNone">Only output every nth sample  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">patch </td><td class="markdownTableBodyNone">glob </td><td class="markdownTableBodyNone">Patch concatenated x column  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clone </td><td class="markdownTableBodyNone">glob n </td><td class="markdownTableBodyNone">Clone matched columns n times  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hmax </td><td class="markdownTableBodyNone">glob </td><td class="markdownTableBodyNone">Add column with the max of matched columns  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hmin </td><td class="markdownTableBodyNone">glob </td><td class="markdownTableBodyNone">Add column with the min of matched columns  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hsum </td><td class="markdownTableBodyNone">glob </td><td class="markdownTableBodyNone">Add column with the sum of matched columns  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">havg </td><td class="markdownTableBodyNone">glob </td><td class="markdownTableBodyNone">Add column with the mean of matched columns  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">precision </td><td class="markdownTableBodyNone">glob digits </td><td class="markdownTableBodyNone">Set a fixed amount of fraction digits  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">style </td><td class="markdownTableBodyNone">format </td><td class="markdownTableBodyNone">Format output (must be the last filter)  </td></tr>
</table>
<h3>Selecting Columns</h3>
<p>The <code>glob</code> argument of a filter is used to select the columns to apply a filter to. The pattern should match the names of the columns without the unit, an optional square bracket enclosure at the end of a column name.</p>
<p>Note the that the horizontal filters <code>hmax</code>, <code>hmin</code>, <code>hsum</code> and <code>havg</code> require that all matched columns have the same unit.</p>
<h3>Pretty Printing</h3>
<p>The following filters can be used to customise output:</p>
<ul>
<li><code>cut=GLOB</code></li>
<li><code>precision=GLOB,DIGITS</code></li>
<li><code>style=FORMAT</code></li>
</ul>
<p>The <code>cut</code> filter selects a subset of columns to output:</p>
<div class="fragment"><div class="line"># obj/loadplay -i loads/freq_tracking.load -o replay.csv obj/powerd++</div>
<div class="line"># tools/playfilter cut=&#39;time|cpu.3.*&#39; -- replay.csv</div>
<div class="line">time[s] cpu.3.rec.freq[MHz] cpu.3.rec.load[MHz] cpu.3.run.freq[MHz] cpu.3.run.load[MHz]</div>
<div class="line">0.025 1700 850.0 1700 850.0</div>
<div class="line">0.050 1700 0.0 1700 0.0</div>
<div class="line">0.075 1700 566.7 1700 566.7</div>
<div class="line">0.100 1700 0.0 1700 0.0</div>
<div class="line">...</div>
</div><!-- fragment --><p>The <code>precision</code> filter sets a fixed number of fraction digits for the matched columns:</p>
<div class="fragment"><div class="line"># tools/playfilter cut=&#39;time|cpu.3.*&#39; precision=&#39;*.load&#39;,3 -- replay.csv</div>
<div class="line">time[s] cpu.3.rec.freq[MHz] cpu.3.rec.load[MHz] cpu.3.run.freq[MHz] cpu.3.run.load[MHz]</div>
<div class="line">0.025 1700 850.000 1700 850.000</div>
<div class="line">0.050 1700 0.000 1700 0.000</div>
<div class="line">0.075 1700 566.700 1700 566.700</div>
<div class="line">0.100 1700 0.000 1700 0.000</div>
<div class="line">...</div>
</div><!-- fragment --><p>The <code>style</code> filter is only allowed as the last filter in the pipeline, because it produces output that is not valid filter input. It formats the output for different applications, the supported styles are:</p>
<ul>
<li><code>CSV</code>: Fields are separated by a <code>,</code> and column names are quoted using <code>"</code></li>
<li><code>MD</code>: The output is formatted as a markdown table</li>
</ul>
<div class="fragment"><div class="line"># tools/playfilter cut=&#39;time|cpu.3.*&#39; precision=&#39;*.load&#39;,3 style=md -- replay.csv</div>
<div class="line">| time[s] | cpu.3.rec.freq[MHz] | cpu.3.rec.load[MHz] | cpu.3.run.freq[MHz] | cpu.3.run.load[MHz] |</div>
<div class="line">|--------:|--------------------:|--------------------:|--------------------:|--------------------:|</div>
<div class="line">|   0.025 |                1700 |             850.000 |                1700 |             850.000 |</div>
<div class="line">|   0.050 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">|   0.075 |                1700 |             566.700 |                1700 |             566.700 |</div>
<div class="line">|   0.100 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">...</div>
</div><!-- fragment --><h3>Subsampling</h3>
<p>The following filters can be used for subsampling:</p>
<ul>
<li><code>subsample=N</code></li>
<li><code>movingavg=GLOB,PRE[,POST]</code></li>
</ul>
<p>If only a subset of the available lines is required, the <code>subsample</code> filter can be used:</p>
<div class="fragment"><div class="line"># tools/playfilter cut=&#39;time|cpu.3.*&#39; subsample=4 precision=&#39;*.load&#39;,3 style=md -- replay.csv</div>
<div class="line">| time[s] | cpu.3.rec.freq[MHz] | cpu.3.rec.load[MHz] | cpu.3.run.freq[MHz] | cpu.3.run.load[MHz] |</div>
<div class="line">|--------:|--------------------:|--------------------:|--------------------:|--------------------:|</div>
<div class="line">|   0.100 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">|   0.200 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">|   0.300 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">|   0.400 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">...</div>
</div><!-- fragment --><p>The above example uses every fourth sample, however that means the information of the other 3 samples is not used. This can be avoided by applying a low-pass filter:</p>
<div class="fragment"><div class="line"># tools/playfilter cut=&#39;time|cpu.3.*&#39; movingavg=&#39;cpu*&#39;,4 subsample=4 precision=&#39;*.load&#39;,3 style=md -- replay.csv</div>
<div class="line">| time[s] | cpu.3.rec.freq[MHz] | cpu.3.rec.load[MHz] | cpu.3.run.freq[MHz] | cpu.3.run.load[MHz] |</div>
<div class="line">|--------:|--------------------:|--------------------:|--------------------:|--------------------:|</div>
<div class="line">|   0.100 |                1700 |             354.175 |                1700 |             354.175 |</div>
<div class="line">|   0.200 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">|   0.300 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">|   0.400 |                1700 |               0.000 |                1700 |               0.000 |</div>
<div class="line">...</div>
</div><!-- fragment --><p>The above example uses a four sample pre-filter, i.e. every sample contains the mean value of the last four samples. Synchronised to the subsampling interval this results in the reported sample containing the mean of the original samples without overlap. For this example the <code>0.100 s</code> sample contains the mean of the original <code>0.025 s</code>, <code>0.050 s</code>, <code>0.075 s</code> and <code>0.100 s</code> samples.</p>
<h3>Imitating <code>powerd(8)</code> Sampling</h3>
<p>The default sample time of <code>powerd(8)</code> is <code>0.250 s</code>:</p>
<div class="fragment"><div class="line"># tools/playfilter cut=&#39;time|cpu.0.*.load&#39; movingavg=&#39;cpu.*&#39;,10 subsample=10 precision=&#39;*.load&#39;,3 style=md -- replay.csv</div>
<div class="line">| time[s] | cpu.0.rec.load[MHz] | cpu.0.run.load[MHz] |</div>
<div class="line">|--------:|--------------------:|--------------------:|</div>
<div class="line">|   0.250 |             396.670 |             396.670 |</div>
<div class="line">|   0.500 |             170.000 |             170.000 |</div>
<div class="line">|   0.750 |               0.000 |               0.000 |</div>
<div class="line">|   1.000 |             405.000 |             405.000 |</div>
<div class="line">...</div>
</div><!-- fragment --><p>However <code>powerd(8)</code> uses the sum of the load of all cores. This can be achieved using one of the horizontal family of filters:</p>
<ul>
<li><code>hmax=GLOB</code> (horizontal maximum)</li>
<li><code>hmin=GLOB</code> (horizontal minimum)</li>
<li><code>hsum=GLOB</code> (horizontal sum)</li>
<li><code>havg=GLOB</code> (horizontal mean)</li>
</ul>
<p>This set of filters creates a new column by aggregating data from the matched columns:</p>
<div class="fragment"><div class="line"># tools/playfilter movingavg=&#39;cpu.*&#39;,10 subsample=10 hsum=&#39;*.run.load&#39; hsum=&#39;*.rec.load&#39; cut=&#39;time|sum*&#39; precision=&#39;sum*&#39;,3 style=md -- replay.csv</div>
<div class="line">| time[s] | sum(cpu.{0,1,2,3}.run.load)[MHz] | sum(cpu.{0,1,2,3}.rec.load)[MHz] |</div>
<div class="line">|--------:|---------------------------------:|---------------------------------:|</div>
<div class="line">|   0.250 |                         1048.340 |                         1048.340 |</div>
<div class="line">|   0.500 |                          212.500 |                          212.500 |</div>
<div class="line">|   0.750 |                            0.000 |                            0.000 |</div>
<div class="line">|   1.000 |                         2115.000 |                         2115.000 |</div>
<div class="line">...</div>
</div><!-- fragment --><p>Note there are separate filter steps for the <code>run.load</code> and <code>rec.load</code> columns to create two separate sums.</p>
<h3>Imitating <code>powerd++(8)</code> Sampling and Filtering</h3>
<p>The default sample rate of <code>powerd++(8)</code> is <code>0.5 s</code> and instead of the sum it uses the maximum. On top of it, it uses the mean of the last 4 sampled maxima:</p>
<div class="fragment"><div class="line"># tools/playfilter movingavg=&#39;cpu.*&#39;,20 subsample=20 hmax=&#39;*.run.load&#39; hmax=&#39;*.rec.load&#39; movingavg=&#39;max*&#39;,4 cut=&#39;time|max*&#39; precision=&#39;max*&#39;,3 style=md -- replay.csv</div>
<div class="line">| time[s] | max(cpu.{0,1,2,3}.run.load)[MHz] | max(cpu.{0,1,2,3}.rec.load)[MHz] |</div>
<div class="line">|--------:|---------------------------------:|---------------------------------:|</div>
<div class="line">|   0.500 |                          283.335 |                          283.335 |</div>
<div class="line">|   1.000 |                          294.168 |                          294.168 |</div>
<div class="line">|   1.500 |                          446.112 |                          449.445 |</div>
<div class="line">|   2.000 |                          525.521 |                          526.771 |</div>
<div class="line">...</div>
</div><!-- fragment --><h3>Side by Side Filter Comparisons</h3>
<p>Columns can be reproduced, so different filters can be applied to the same data:</p>
<ul>
<li><code>clone=GLOB,N</code></li>
</ul>
<p>This can be used to compare the effects of different filters:</p>
<div class="fragment"><div class="line"># tools/playfilter cut=&#39;time|cpu.0.rec.load&#39; clone=&#39;*.load&#39;,2 movingavg=&#39;*.load.0&#39;,80 movingavg=&#39;*.load.1&#39;,40,40 precision=&#39;cpu.*&#39;,3 style=md -- replay.csv</div>
<div class="line">| time[s] | cpu.0.rec.load[MHz] | cpu.0.rec.load.0[MHz] | cpu.0.rec.load.1[MHz] |</div>
<div class="line">|--------:|--------------------:|----------------------:|----------------------:|</div>
<div class="line">|   0.025 |            1700.000 |              1700.000 |               236.993 |</div>
<div class="line">|   0.050 |            1700.000 |              1700.000 |               259.921 |</div>
<div class="line">|   0.075 |             566.700 |              1322.230 |               281.784 |</div>
<div class="line">|   0.100 |               0.000 |               991.675 |               302.652 |</div>
<div class="line">...</div>
</div><!-- fragment --><p>The column <code>cpu.0.rec.load</code> contains the original data, <code>cpu.0.rec.load.0</code> applies a <code>2 s</code> moving average. The <code>cpu.0.rec.load.1</code> column contains a symmetric <code>2 s</code> moving average (i.e. <code>1 s</code> pre and <code>1 s</code> post), which is the best in hindsight representation of a filtered value.</p>
<p>Plotting these illustrates that this produces the same curve with a <code>1 s</code> offset. This illustrates how a <code>2 s</code> moving average causes <code>1 s</code> of latency reacting to load events like spikes and drops.</p>
<h3>Serialising Multiple Replays</h3>
<p>It is possible to concatenate multiple replays, but it usually requires patching the <code>time</code> column:</p>
<ul>
<li><code>patch=GLOB</code></li>
</ul>
<p>Without patching, the time column jumps back down when transitioning from one file to the next:</p>
<div class="fragment"><div class="line"># tools/playfilter movingavg=&#39;*.run.load&#39;,20 subsample=20 hmax=&#39;*.run.load&#39; cut=&#39;time|max*|cpu.0.run.freq&#39; movingavg=&#39;max*&#39;,4 precision=time,3 precision=&#39;max*&#39;,1 style=md -- replay.csv replay.csv</div>
<div class="line">| time[s] | cpu.0.run.freq[MHz] | max(cpu.{0,1,2,3}.run.load)[MHz] |</div>
<div class="line">|--------:|--------------------:|---------------------------------:|</div>
<div class="line">|   0.500 |                1700 |                            283.3 |</div>
<div class="line">|   1.000 |                1400 |                            294.2 |</div>
<div class="line">|   1.500 |                1200 |                            446.1 |</div>
<div class="line">|   2.000 |                1300 |                            525.5 |</div>
<div class="line">...</div>
<div class="line">|  28.500 |                1800 |                            732.8 |</div>
<div class="line">|  29.000 |                2000 |                            665.3 |</div>
<div class="line">|  29.500 |                1900 |                            690.1 |</div>
<div class="line">|  30.000 |                1900 |                            810.0 |</div>
<div class="line">|   0.500 |                1700 |                            593.3 |</div>
<div class="line">|   1.000 |                1400 |                            650.8 |</div>
<div class="line">|   1.500 |                1200 |                            525.8 |</div>
<div class="line">|   2.000 |                1300 |                            525.5 |</div>
<div class="line">...</div>
<div class="line">|  28.500 |                1800 |                            732.8 |</div>
<div class="line">|  29.000 |                2000 |                            665.3 |</div>
<div class="line">|  29.500 |                1900 |                            690.1 |</div>
<div class="line">|  30.000 |                1900 |                            810.0 |</div>
</div><!-- fragment --><p>The <code>patch</code> filter uses the previous value as an offset for following values if the new value is less than or equal to the previous one:</p>
<div class="fragment"><div class="line"># tools/playfilter patch=time movingavg=&#39;*.run.load&#39;,20 subsample=20 hmax=&#39;*.run.load&#39; cut=&#39;time|max*|cpu.0.run.freq&#39; movingavg=&#39;max*&#39;,4 precision=time,3 precision=&#39;max*&#39;,1 style=md -- replay.csv replay.csv</div>
<div class="line">| time[s] | cpu.0.run.freq[MHz] | max(cpu.{0,1,2,3}.run.load)[MHz] |</div>
<div class="line">|--------:|--------------------:|---------------------------------:|</div>
<div class="line">|   0.500 |                1700 |                            283.3 |</div>
<div class="line">|   1.000 |                1400 |                            294.2 |</div>
<div class="line">|   1.500 |                1200 |                            446.1 |</div>
<div class="line">|   2.000 |                1300 |                            525.5 |</div>
<div class="line">...</div>
<div class="line">|  28.500 |                1800 |                            732.8 |</div>
<div class="line">|  29.000 |                2000 |                            665.3 |</div>
<div class="line">|  29.500 |                1900 |                            690.1 |</div>
<div class="line">|  30.000 |                1900 |                            810.0 |</div>
<div class="line">|  30.500 |                1700 |                            593.3 |</div>
<div class="line">|  31.000 |                1400 |                            650.8 |</div>
<div class="line">|  31.500 |                1200 |                            525.8 |</div>
<div class="line">|  32.000 |                1300 |                            525.5 |</div>
<div class="line">...</div>
<div class="line">|  58.500 |                1800 |                            732.8 |</div>
<div class="line">|  59.000 |                2000 |                            665.3 |</div>
<div class="line">|  59.500 |                1900 |                            690.1 |</div>
<div class="line">|  60.000 |                1900 |                            810.0 |</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
