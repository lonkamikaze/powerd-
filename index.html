<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>powerd++: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">powerd++
   &#160;<span id="projectnumber">0.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">powerd++ Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="fragment"><div class="line">                                      /\  __</div><div class="line">   __ __ ___  ___  __ _____  ___  ___/ /_/ /_</div><div class="line">  /_//_//   \/   \/ // / _ \/ __\/    /_   _/__</div><div class="line"> __ __ / // / // /    / ___/ /  / // /  /_/_/ /_</div><div class="line">/_//_// ___/\___/\_/_/\___/_/   \___/     /_  _/</div><div class="line">     / /                                   /_/</div><div class="line">     \/ multi-core CPU clock daemon for FreeBSDÂ®</div></div><!-- fragment --><p>The <code>powerd++</code> daemon is a drop-in replacement for FreeBSD's native <code>powerd(8)</code>. It monitors CPU load and core temperatures to adjust the CPU clock, avoiding some of the pitfalls of <code>powerd</code>.</p>
<h2>What Pitfalls? </h2>
<p>At the time <code>powerd++</code> was first created (February 2016), <code>powerd</code> exhibited some unhealthy behaviours on multi-core machines.</p>
<p>In order to make sure that single core loads do not suffer from the use of <code>powerd</code> it was designed to use the sum load of all cores as the current load rating. A side effect of this is that it causes <code>powerd</code> to never clock down on systems with even moderate numbers of cores. E.g. on a quad-core system with hyper threading a background load of 12.5% per core suffices to score a 100% load rating.</p>
<p>The more cores are added, the worse it gets. Even on a dual core machine (with HT) having a browser and an e-mail client open, suffices to keep the load rating above 100% for most of the time, even without user activity. Thus <code>powerd</code> never does its job of saving energy by reducing the clock frequency.</p>
<h2>Advantages of powerd++ </h2>
<p>The <code>powerd++</code> implementation addresses this issue and more:</p>
<ul>
<li><code>powerd++</code> groups cores with a common clock frequency together and handles each group's load and target frequency separately. I.e. the moment FreeBSD starts offering individual clock settings on the CPU, core or thread level, <code>powerd++</code> already supports it.</li>
<li><code>powerd++</code> takes the highest load within a group of cores to rate the load. This approach responds well to single core loads as well as evenly distributed loads.</li>
<li><code>powerd++</code> sets the clock frequency according to a load target, i.e. it jumps right to the clock rate it will stay in if the load does not change.</li>
<li><code>powerd++</code> supports taking the average load over more than two samples, this makes it more robust against small load spikes, but sacrifices less responsiveness than just increasing the polling interval would. Because only the oldest and the newest sample are required for calculating the average, this approach does not even cause additional runtime cost!</li>
<li><code>powerd++</code> parses command line arguments as floating point numbers, allowing expressive commands like <code>powerd++ --batt 1.2ghz</code>.</li>
<li><code>powerd++</code> supports temperature based throttling.</li>
</ul>
<h2>Building </h2>
<p>Download the repository and run <code>make</code>: </p><pre class="fragment">&gt; make
c++ -O2 -pipe  -std=c++14 -Wall -Werror -pedantic -c src/powerd++.cpp -o powerd++.o
c++ -O2 -pipe  -std=c++14 -Wall -Werror -pedantic -c src/clas.cpp -o clas.o
c++ -O2 -pipe  -std=c++14 -Wall -Werror -pedantic powerd++.o clas.o -lutil -o powerd++
c++ -O2 -pipe  -std=c++14 -Wall -Werror -pedantic -c src/loadrec.cpp -o loadrec.o
c++ -O2 -pipe  -std=c++14 -Wall -Werror -pedantic loadrec.o clas.o -o loadrec
c++ -O2 -pipe  -std=c++14 -Wall -Werror -pedantic -fPIC -c src/loadplay.cpp -o loadplay.o
c++ -O2 -pipe  -std=c++14 -Wall -Werror -pedantic loadplay.o -lpthread -shared -o libloadplay.so
</pre><h2>Documentation </h2>
<p>The manual pages can be read with the following commands: </p><pre class="fragment">&gt; man man/powerd++.8 man/loadrec.1 man/loadplay.1
</pre><h2>Load Recording and Replay </h2>
<p>In addition to the <code>powerd++</code> daemon this repository also comes with the tools <code>loadrec</code> and <code>loadplay</code>. They can be used to record loads and test both <code>powerd</code> and <code>powerd++</code> under reproducible load conditions.</p>
<p>This is great for tuning, testing, bug reports and creating fancy plots.</p>
<h2>FAQ </h2>
<ul>
<li><b>Why C++?</b> The <code>powerd++</code> code is not object oriented, but it uses some <em>C++</em> and <em>C++11</em> features to avoid common pitfalls of writing <em>C</em> code. E.g. there is a small <em>RAII</em> wrapper around the pidfile facilities (<code><a class="el" href="loadplay_8cpp.html#a2142be902525c0f4e400b856a257f236" title="Intercept calls to pidfile_open().">pidfile_open()</a></code>, <code><a class="el" href="loadplay_8cpp.html#a997be1ed42ba47290ef37df12ebf5cc3" title="Intercept calls to pidfile_write().">pidfile_write()</a></code>, <code><a class="el" href="loadplay_8cpp.html#aedfdf0b29a3e52a8458c1a39d70e3c9c" title="Intercept calls to pidfile_remove().">pidfile_remove()</a></code>), turning the use of pidfiles into a fire and forget affair. Templated wrappers around calls like <code><a class="el" href="loadplay_8cpp.html#ad972ce2a8b2b31fabc47aaf1e57b1bfc" title="Functions to intercept.">sysctl()</a></code> use array references to infer buffer sizes at compile time, taking the burden of safely passing these buffer sizes on to the command away from the programmer. The <code>std::unique_ptr&lt;&gt;</code> template obsoletes memory cleanup code, providing the liberty of using exceptions without worrying about memory leaks.</li>
<li><b>Why does powerd++ show a high load when top shows a high idle time?</b> By default <code>top</code> shows the load percentage over all cores/threads, <code>powerd++</code> uses the load of a single core/thread (the one with the highest load). This keeps <code>powerd++</code> from starving single threaded processes, because they only have a small impact on overall load. An effect that increases with the number of cores/threads. E.g. 80% load on a quad core CPU with hyper threading only has an overall load impact of 10%. Use <code>top -P</code> to monitor idle times per core/thread.</li>
</ul>
<h2>LICENSE </h2>
<p>For those who care about this stuff, this project is available under the <a class="el" href="md__usr_home_kamikaze_stark_freebsd_powerdxx_8git_LICENSE.html">ISC license</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
