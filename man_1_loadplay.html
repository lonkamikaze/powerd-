<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>powerd++: Manual loadplay(1)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">powerd++
   &#160;<span id="projectnumber">0.4.3+c4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Manual loadplay(1) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre>
loadplay(1)             FreeBSD General Commands Manual            loadplay(1)</pre><pre><b>NAME</b>
     <b>loadplay</b> – CPU load player</pre><pre><b>SYNOPSIS</b>
     <b>loadplay</b> <b>-h</b>
     <b>loadplay</b> [<b>-i</b> <u>file</u>] [<b>-o</b> <u>file</u>] <u>command</u> [...]</pre><pre><b>DESCRIPTION</b>
     The <b>loadplay</b> command replays a load recording created with loadrec(1).
     The <u>command</u> can either be powerd(8) or powerd++(8), compatibility with
     other tools has not been tested.</pre><pre>   <b>OPTIONS</b>
     The following options are supported:</pre><pre>     <b>-h</b>, <b>--help</b>
             Show usage and exit.</pre><pre>     <b>-i</b>, <b>--input</b> <u>file</u>
             Read load recording from <u>file</u> instead of <u>stdin</u>.</pre><pre>     <b>-o</b>, <b>--output</b> <u>file</u>
             Output statistics to <u>file</u> instead of <u>stdout</u>.</pre><pre><b>USAGE</b> <b>NOTES</b>
     The <b>loadplay</b> command injects <u>libloadplay.so</u> into <u>command</u>.  This library
     simulates the load from the input and outputs load statistics.</pre><pre>   <b>OUTPUT</b>
     The first line of output contains column headings, columns are separated
     by a single space.</pre><pre>     The Following columns are present, columns containing <b>%d</b> occur for each
     core simulated:</pre><pre>     <b>time[s]</b>
             The simulation progress in 0.001 second resolution.</pre><pre>     <b>cpu.%d.rec.freq[MHz]</b>
             The recorded clock frequency, sampled at the end of the frame.</pre><pre>     <b>cpu.%d.rec.load[MHz]</b>
             The recorded load in 0.1 MHz resolution.</pre><pre>     <b>cpu.%d.run.freq[MHz]</b>
             The simulated clock frequency set by the host process, sampled at
             the end of the frame.</pre><pre>     <b>cpu.%d.run.load[MHz]</b>
             The simulated load in 0.1 MHz resolution.</pre><pre>   <b>SAMPLING</b>
     There is one sample for each recorded line. The duration of each frame
     depends on the recording, which defaults to 25&#160;ms.  At this sample rate
     loads are dominated by noise, so a gliding average should be applied to
     any load columns for further use, such as plotting.</pre><pre><b>IMPLEMENTATION</b> <b>NOTES</b>
     The injected <u>libloadplay.so</u> works by intercepting system function calls
     and substituting the host environment with the recording. To achieve this
     the following function calls are intercepted:</pre><pre>     <b>•</b>   sysctl(3), sysctlnametomib(3), sysctlbyname(3)</pre><pre>     <b>•</b>   daemon(3)</pre><pre>     <b>•</b>   geteuid(2)</pre><pre>     <b>•</b>   pidfile_open(3), pidfile_write(3), pidfile_close(3),
         pidfile_remove(3), pidfile_fileno(3)</pre><pre>   <b>INITIALISATION</b>
     The <b>sysctl</b> family of functions is backed by a table that is initialised
     from the header of the load recording. If the heading is incomplete the
     setup routines print a message on <u>stderr</u>.  All the following intercepted
     function calls will return failure, ensuring that the host process is
     unable to operate and terminates.</pre><pre>     Like powerd++(8) and loadrec(1) <b>loadplay</b> is core agnostic. Meaning that
     any core may have a <b>.freq</b> and <b>.freq</b><b><u>_</u></b><b>levels</b> sysctl handle. Due to this
     flexibility load recordings may in part or wholly be fabricated to test
     artificial loads or systems and features that do not yet exist. E.g. it
     is possible to offer a <b>.freq</b> handle for each core or fabricate new
     <b>.freq</b><b><u>_</u></b><b>levels</b>.</pre><pre>   <b>SIMULATION</b>
     If setup succeeds a simulation thread is started that reads the remaining
     input lines, simulates the load and updates the <b>kern.cp</b><b><u>_</u></b><b>times</b> entry in
     the thread safe sysctl table. For each frame a line of output with load
     statistics is produced.</pre><pre>     Interaction with the host process happens solely through the sysctl
     table. The simulation reads the recorded loads and the current core
     frequencies to update <b>kern.cp</b><b><u>_</u></b><b>times</b>.  The host process reads this data
     and adjusts the clock frequencies, which in turn affects the next frame.</pre><pre>   <b>FINALISATION</b>
     After reading the last line of input the simulation thread sends a <b>SIGINT</b>
     to the process to cause it to terminate.</pre><pre><b>ENVIRONMENT</b>
     LOADPLAY_IN
             If set the file named is used for input instead of <u>stdin</u>.  This
             only affects the input of <b>loadplay</b>, the host process is not
             affected.</pre><pre>     LOADPLAY_OUT
             If set the file named is used for output instead of <u>stdout</u>.  This
             only affects the output of <b>loadplay</b>, the host process is not
             affected.</pre><pre>     LD_PRELOAD
             Used to inject <u>libloadplay.so</u> into the host process.</pre><pre><b>FILES</b>
     <u>/usr/local/lib/libloadplay.so</u>
             A library injected into <u>command</u> via the LD_PRELOAD environment
             variable.</pre><pre><b>EXAMPLES</b>
     Play a load recording with <b>loadplay</b>:</pre><pre>         &gt; loadplay -i loads/freq_tracking.load powerd++
         time[s] cpu.0.rec.freq[MHz] cpu.0.rec.load[MHz] cpu.0.run.freq[MHz] cpu.0.run.load[MHz] cpu.1.rec.freq[MHz] cpu.1.rec.load[MHz] cpu.1.run.freq[MHz] cpu.1.run.load[MHz] cpu.2.rec.freq[MHz] cpu.2.rec.load[MHz] cpu.2.run.freq[MHz] cpu.2.run.load[MHz] cpu.3.rec.freq[MHz] cpu.3.rec.load[MHz] cpu.3.run.freq[MHz] cpu.3.run.load[MHz]
         0.025 1700 1700.0 1700 1700.0 1700 0.0 1700 0.0 1700 1700.0 1700 1700.0 1700 850.0 1700 850.0
         0.050 1700 1700.0 1700 1700.0 1700 1700.0 1700 1700.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.075 1700 566.7 1700 566.6 1700 1700.0 1700 1700.0 1700 0.0 1700 0.0 1700 566.7 1700 566.6
         0.100 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.125 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.150 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.175 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.200 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.225 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.250 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.275 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0</pre><pre>     Capture load and <b>loadplay</b> output simultaneously into two different files:</pre><pre>         &gt; loadplay -i loads/freq_tracking.load -o load.csv powerd++ -f &gt; load.out</pre><pre>     Capture and display <b>loadplay</b> output:</pre><pre>         &gt; loadplay -i loads/freq_tracking.load -o load.csv powerd++ -f | tee load.out
         power:  online, load:  527 MHz, cpu0.freq: 1700 MHz, wanted: 1405 MHz
         power:  online, load:  459 MHz, cpu0.freq: 1400 MHz, wanted: 1224 MHz
         power:  online, load:  502 MHz, cpu0.freq: 1200 MHz, wanted: 1338 MHz
         power:  online, load:  548 MHz, cpu0.freq: 1300 MHz, wanted: 1461 MHz
         power:  online, load:  704 MHz, cpu0.freq: 1500 MHz, wanted: 1877 MHz
         power:  online, load:  750 MHz, cpu0.freq: 1900 MHz, wanted: 2000 MHz
         power:  online, load:  805 MHz, cpu0.freq: 2000 MHz, wanted: 2146 MHz
         power:  online, load:  772 MHz, cpu0.freq: 2200 MHz, wanted: 2058 MHz
         power:  online, load:  574 MHz, cpu0.freq: 2000 MHz, wanted: 1530 MHz
         power:  online, load:  515 MHz, cpu0.freq: 1500 MHz, wanted: 1373 MHz</pre><pre><b>SEE</b> <b>ALSO</b>
     loadrec(1), powerd(8), powerd++(8), rtld(1), signal(3), tee(1)</pre><pre><b>AUTHORS</b>
     Implementation and manual by Dominic Fandrey &lt;<u>kami@freebsd.org</u>&gt;</pre><pre>FreeBSD 12.1-STABLE            3 September, 2019           FreeBSD 12.1-STABLE
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
